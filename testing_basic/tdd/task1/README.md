# 課題1

## Table of Contents
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<details>
<summary>Details</summary>

- [質問1](#%E8%B3%AA%E5%95%8F1)
  - [回答](#%E5%9B%9E%E7%AD%94)
- [質問2](#%E8%B3%AA%E5%95%8F2)
  - [回答](#%E5%9B%9E%E7%AD%94-1)

</details>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 質問1

> テスト駆動開発のメリットと、デメリット

### 回答

- メリット
  - テストを先に書いていくため、テストしやすいコードを書くことができる
  - 設計を常に意識してコードを書くことができる
  - 仕様が理解しやすいテストコードを書くことができる（ドキュメントとしての役割を持つようにテストコードを書くため）
- デメリット
  - 慣れが必要であり、実践できるようになるまでに時間がかかる
  - テストコードのメンテナンスコストがかかる
    - 仕様が変化した場合は、テストコードも修正する必要があるため、仕様が頻繁に変化する場合には向いていないように思う
  - 既存のレガシーコードに適用することは難しい
    - 既存のアプリケーションの実装でTDDを採用する場合は、新機能の実装や機能修正のタイミングで採用することになると思う
  - 

## 質問2

> TDDにおける以下の用語の意味を説明してください

### 回答

|用語|概要|備考|
|---------|---------------------|--------------|
|レッド・グリーン・リファクタリング|（レッド）失敗するテストコードを書く。コンパイルエラーもレッドに含まれる <br> （グリーン）汚いコードで良いので、成功するテストコードを書く。<br> （リファクタリング）テストを通すために、発生した重複を全て取り除く。||
|仮実装|TDDのサイクルにおける、1周目に行われる実装で、汚いコードで良いので、テストを成功（グリーン）させること||
|三角測量|コードに対してテストがきちんとチェックできているかを、同じ対象に対して別の観点を追加する。そしてその観点でテストがグリーンになるように、コードの一般化を行う。|一般化の方法が不明な場合に三角測量を行い、それ以外の場合は仮実装や明白な実装を選択する。|
|明白な実装|うまくいく実装方法が浮かんでいる状態で、その実装を行い、テストを成功させること|うまくいく方法が浮かんでいる場合は、仮実装や三角測量を行う必要はない。明白な実装中に、テストが失敗した場合はまた仮実装に戻る。|

## テスト駆動開発(TDD)に関する整理

- テスト駆動開発の発案者
  - Kent Beckさん

### テスト駆動開発のサイクル

- まずTODOリストを作る
  - タスク分解や整理の良い練習方法
    - テスト容易性が高いものがどのようなものかをわかるようになること（経験）
      - 最初はできなくても良いので、まずはやってみるとわかるようになってくる
    - また、設計について勉強すると良い（理論）
      - 例えばClean Architecture

![](../../../assets/tdd_cycle.png)
- 3のテストを実行して失敗させる
  - Javaであれば、`fail()`メソッドを使ってメッセージが表示されることを確認する
    - 表示されない場合は、そもそも事前準備に問題があるとわかる
  - コンパイルエラーであっても、Redに数える
    - 静的であっても動的であっても目の前のエラーはRed
  - テストの段階は代表的な3Aパターンでは以下の3つであり、TDDでは下のAssertから書く
    - 準備（Assert）
    - 実行（Act）
    - 検証（Assert）
      - 上から書くと何をやろうとしているか、忘れがち。本来の検証内容と関係ないテストをたくさん書いてしまいがち
- 4の目的のコードを書く
  - **汚くて良い**ので成功するコードを書く
  - テストコードにバグがある場合どうするのか
    - 判別可能な誤りをいれる
    - 予想通りテストが失敗することを確認する（defect insertion）
      - これを自動でやるのが、mutation testing
- 6のリファクタリング
  - Martin Fowlerさんのリファクタリングの定義
    - ソフトウェアの外部から見た振る舞いを変えずに、理解や保守が容易になるようにソフトウェアの内部を綺麗にしていくこと
  - Kent Beckさんのリファクタリングの定義
    - 成功しているテストが成功しているままでコードを綺麗にしていくこと
    - ソフトウェアの外部から見た振る舞い、とは少し定義が曖昧なので、Kentさんはそれを言い換えた
  - リファクタは永遠にやりがち
    - 案1：時間で区切る
    - 案2：数を数える
      - 1を目指す
        - コピペすると重複したコードができてしまうが、それをなくすと1になる（重複をなくす）
- よくある誤解
  - 設計をしない→そうではなく、常に設計し続ける（アジャイル開発も同様）
    - 設計はTODOリストとして、箇条書きで共有する
    - 粒度を最初から揃える必要はなく、まず脳内の思考をダンプすることが重要
- 「動作する綺麗なコード」
  - まず「動作する」汚いコードを書く、次に動作しているままで、「綺麗な」コードを書く
  - 2つの方法
    - 重要なテストから取り組む
    - テストを書きやすいテストから取り組む（テスト容易性が高い）→TDDではこちらから取り組む
      - TDDはやることが多いため、1周目や2周目で重要なテストを行うと作業が重いため
        - 1周目が重いのは、何もないところから作る必要があるため。設計の色合いが強い
      - 重要なものがテスト容易性が低いわけではなく、そういうものでもテスト容易性を高くすることができる
      - テスト容易性が高いとは
        - 観測が簡単
        - 制御が簡単
        - 対象が十分小さいこと
- TDDのスキル
  - 問題を小さく分割する
  - 歩幅を調整する
  - テストの構造化とリファクタリング
    - 構造化とリファクタまで、テスト作成者本人が行わないと、その後に直すことは本人含め非常に難しい
- 仮実装
  - TDD開発の1周目で行われる。ひどいコードで良い。
- 三角測量
  - 仮実装に対して、まともな方向に戻す
  - ただし、実装に不安がなくなってきたら、三角測量は飛ばして、実装を行っても良い

### その他のTips
  - 日本語でテストを共有しても問題ない場合は、日本語で書くことを推奨する
    - テストコードからテストの内容を読み取れるドキュメントとして、成立してほしい
  - Assertを縦に並べず、別のテストとして切り出す
    - Assertion Rouletteと言われる、アンチパターンであるため
      - 途中でAssertが失敗すると、次のAssertが実行されないので、テストされない（そのテストをしたときにどうなるかがわからない状態になってしまう）
        - どのAssertで失敗してるのかを確かめる必要がある
        - テストする際に失敗したかったときに、デバッグから始める必要がある
        - ドキュメントとして読んだときに仕様がわかりにくい
      - 理想としては、1つのテストで1つのAssertionが望ましい（One Assertion per Testと呼ばれる）
        - テストごとにAssertionが1つであれば、どこで失敗したかが自明
        - 複数のAssertionをしたい場合は、テストを分解すべきか、もしくは分解が誤ってるのか？
          - Assertionを複数OKな場合
            - まとめてAssertionしなければ意味がない場合は、複数でもOK
            - 例えばE2Eテストなどの動作が遅いテスト
          - ただし、まずは分解の方を疑って、分解できないかを考えることを推奨する！
              

## 参考

- [見てわかるテスト駆動開発](https://www.youtube.com/watch?v=Q-FJ3XmFlT8)
- テスト駆動開発(書籍)
- [ミクシィにおけるTDD実践してわかったメリットとデメリット](https://logmi.jp/tech/articles/320541)
- [Pros and Cons of Test Driven Development](https://devqa.io/pros-cons-test-driven-development/)