# 課題1

## Table of Contents
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<details>
<summary>Details</summary>

- [質問1](#%E8%B3%AA%E5%95%8F1)
- [回答](#%E5%9B%9E%E7%AD%94)
- [Web脆弱性に関しての整理](#web%E8%84%86%E5%BC%B1%E6%80%A7%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6%E3%81%AE%E6%95%B4%E7%90%86)
  - [各脆弱性に対する対応](#%E5%90%84%E8%84%86%E5%BC%B1%E6%80%A7%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E5%AF%BE%E5%BF%9C)
    - [XSS](#xss)
    - [コマンドインジェクション](#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)
    - [SQLインジェクション](#sql%E3%82%A4%E3%83%B3%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)
    - [CSRF](#csrf)
- [参考](#%E5%8F%82%E8%80%83)

</details>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 質問1

> 以下の脆弱性の仕組み、発生し得る被害、対処法を解説してください

- XSS
- コマンドインジェクション
- SQLインジェクション
- CSRF

## 回答

|脆弱性|仕組み|発生しうる被害|対処法|備考|
|------|-------------|--------------|--------------|--------------|
|XSS（クロスサイトスクリプティング）|外部からの入力(例えばフォーム入力)に応じて、表示が変化する箇所がある場合に、意図しないHTMLやJavaScriptを埋め込まれてしまうこと。|・本物サイト上に偽のページが表示される<br>・ブラウザが保存しているCookieを取得される<br>・任意のCookieをブラウザに保存させられる|[各脆弱性に対する対応の「XSS」](#xss)参照|・攻撃は`<script>`タグのみによるとは限らず、HTML要素を注入することによる画面の書き換えなども存在する<br>・[OWASP Top Ten 2017](https://owasp.org/www-project-top-ten/2017/Top_10.html)では、7番目|
|コマンドインジェクション|シェル経由でOSコマンドを実行可能な言語を利用している場合に、意図しないOSコマンドが実行されてしまうこと。|・サーバ内ファイルの閲覧、改ざん、削除<br>・不正なシステム操作<br>・不正なプログラムのダウンロード、実行<br>・他のシステムへの攻撃の踏み台|[各脆弱性に対する対応の「コマンドインジェクション」](#コマンドインジェクション)参照|<br>・[OWASP Top Ten 2017](https://owasp.org/www-project-top-ten/2017/Top_10.html)では、1番目(Injectionとしてまとめられている)|
|SQLインジェクション|外部からの入力を元にSQLを組み立てている場合に、意図しないSQL文を実行させられてしまうこと。|・データベースに蓄積された非公開情報の閲覧<br>・データベースに蓄積された情報の改ざん、消去<br>・認証回避による不正ログイン<br>・ストアドプロシージャ等を利用したOSコマンドの実行|[各脆弱性に対する対応のSQLインジェクション](#sqlインジェクション)参照|<br>・[OWASP Top Ten 2017](https://owasp.org/www-project-top-ten/2017/Top_10.html)では、1番目(Injectionとしてまとめられている)|
|CSRF（クロスサイトリクエストフォージェリ）|・ログインした状態にあるユーザが意図しないリクエストを実行させられること。|・ログイン後のユーザのみが利用可能なサービスの悪用<br>・ログイン後のユーザのみが編集可能な情報の改ざん、新規登録|[各脆弱性に対する対応のCSRF](#csrf)参照|**XSSとの違いは、以下の３つ（攻撃範囲はXSSの方が広い）。**<br>・実行の前提としてログイン状態であること<br>・アプリケーションで定義された処理が可能であること<br>・実行されるのはクライアント側ではなく、サーバ側であること|

## Web脆弱性に関しての整理

### 各脆弱性に対する対応

#### XSS

- **Rule#0**：次のRule#1~5に当てはまらない限り、データの受け取りを拒否すること
  - HTMLには多くの奇妙なコンテキストが存在するため、エンコードのルールのリストは非常に複雑になる
  - 信頼できないソースからJavaScriptのコードを受け入れて実行しないようにすること！（例えば`callback`という名前を含むパラメータなど）
- **Rule#1**：信頼できないデータをHTML要素に配置したい場合は、HTMLエンコードやエスケープすること

```
 & --> &amp;
 < --> &lt;
 > --> &gt;
 " --> &quot;
 ' --> &#x27;

 &apos; not recommended because its not in the HTML spec (See: section 24.4.1) &apos; is in the XML and XHTML specs.
```

- **Rule#2**：信頼できないデータをHTML要素に配置したい場合は、属性エンコードすること
  - 新たな属性値として挿入されることを防ぐため、英数字を除き、ASCII値が256未満のすべての文字を`＆＃xHH;`でエンコードする

- **Rule#3**：信頼できないデータをJavaScript内に配置したい場合は、JavaScriptをエンコードすること

- **Rule#4**：信頼できないデータをStyleのプロパティ値に配置したい場合は、CSSをエンコードし、厳密な検証を行うこと

- **Rule#5**：信頼できないデータをURLのパラメータ(GETのパラメータ)に配置したい場合は、URLをエンコードすること

- **Rule#6**：ライブラリを使用して、HTMLのテキストのサニタイズを行う

- **Rule#7**：`javascript:`を含むURLを回避する
  - `javascript:`で始まるURLは、`<a>`タグの`href`属性や`<iframe>`の`src`属性の値として設定されると、JavaScriptのコードを実行してしまう

- **Rule#8**：Dom Based XSSを防ぐ
  - Dom Based XSSとは
    - ブラウザ上で動くJavaScriptによって発生する種類のXSS
    - 例えば、以下のようにフラグメントが以下のように設定されると、`alert(1)`が実行されてしまう

```
http://example.jp/#<img src=1 onerror=alert(1)>
```

- **Bonus Rule#1**：クッキーに`HTTPOnly`属性を付与する
  - `HttpOnly`属性を持つクッキーは、JavaScript の Document.cookie API ではアクセスできない

- **Bonus Rule#2**：Content Security Policy(CSP)を適用する
  - > クロスサイトスクリプティング (XSS) やデータインジェクション攻撃などのような、特定の種類の攻撃を検知し、影響を軽減するために追加できるセキュリティレイヤーです。これらの攻撃はデータの窃取からサイトの改ざん、マルウェアの拡散に至るまで、様々な目的に用いられます。
  - > サーバー管理者が CSP を利用する場合、実行を許可するスクリプトの正しいドメインをブラウザーに向けて指定することにより、 XSS の発生する箇所を削減・根絶することができます。 **CSP をサポートするブラウザーは、サーバーから指定された許可リストに載っているドメインのスクリプトのみ実行し、他のスクリプトはすべて無視します** (インラインスクリプトや HTML 属性値のイベントハンドラも無視する対象に含まれます)。
  - > 究極的な防衛策として、スクリプトを決して実行させたくないサイトは、スクリプトの実行を全面的に拒否することも可能です。
  - CSPを有効にする方法
    - webサーバから以下のように`Content-Security-Policy`ヘッダを返す（以下は、サイト管理者が、すべてのコンテンツをサイト自身のドメイン (サブドメインを除く) から取得させたい場合）
    - `<meta>`タグを用いて以下のようにポリシーを指定する

```bash
Content-Security-Policy: default-src 'self'
```

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```

- **Bonus Rule#3**：自動エスケープのテンプレートシステムを使用する
  - 多くのWebフレームワークには、自動でエスケープを行う機能を提供している（e.g.AngularJS、Go）

- **Bonus Rule#4**：モダンなJSフレームワークを適切に使用する
  - モダンなJSフレームワークは、標準でXSS対策が組み込まれている

- HTTPレスポンスヘッダのContent-Typeフィールドの文字コード（charset）を省略しない
  - 例えば以下の文字列が埋め込まれた場合、一部のブラウザは「UTF-7」として解釈した結果、`<script>alert('test');</script>`として扱われ、スクリプトが実行される可能性がある

  ```html
  +ADw-script+AD4-alert(+ACI-test+ACI-)+ADsAPA-/script+AD4-
  ```

- 補足
  - `X-XSS-Protection`について
    - このヘッダの使用は、クライアント側でセキュリティ問題を発生させる可能性があるため、モダンなブラウザでは非推奨となっている

- 参考
  - [Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
  - [安全なウェブサイトの作り方 - 1.5 クロスサイト・スクリプティング](https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_5.html)
  - [第6回　DOM-based XSS　その1](https://gihyo.jp/dev/serial/01/javascript-security/0006)
  - [コンテンツセキュリティポリシー (CSP)](https://developer.mozilla.org/ja/docs/Web/HTTP/CSP)

#### コマンドインジェクション

- **Defense Option1**：OSコマンドを直接呼び出さない
  - 例えば、PHPの場合、`system("mkdir /dir_name")`の代わりに、`mkdir()`を使用するなど

- **Defense Option2**：OSコマンドに渡すパラメータを安全な関数でエスケープする
  - 例えば、PHPの場合、`escapeshellarg()`（徳丸さんによると、同種の関数に`escapeshellcmd()`が存在するが、使い方によっては脆弱性の原因となるので、徳丸さんは非推奨）

- **Defense Option3**：入力検証とパラメータ化
  - コマンド名とパラメータの分離を矯正する関数を利用する
    - 例えば、PHPの場合、`system("/bin/grep $keyword /var/data/*.txt")`のようにコマンドをそのまま実行するのではなく、`system('/bin/grep', '--', $keyword, glob('/var/data/*.txt'))`のようにコマンド名とパラメータを分離する
    - これにより、シェルを経由しないため、OSコマンドインジェクションが混入する危険がなくなる
  - コマンド名とパラメータの両方を検証する

- **Additional Defenses**
  - アプリケーションの稼働するユーザ権限を最小限にする
  - WebサーバのOSやミドルウェアのパッチを適用する
    - OS内部からOSの脆弱性をついた攻撃を受ける場合、権限昇格の脆弱性を疲れた結果、root権限を奪われる場合があるため

- 参考
  - [OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)
  - [安全なウェブサイトの作り方 - 1.2 OSコマンド・インジェクション](https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_2.html)

#### SQLインジェクション

- **Defense Option 1**：パラメータ化されたクエリとプリペアドステートメントを使用する
  - 静的プレースホルダを使用することが推奨される（動的プレースホルダでも、SQLインジェクションの脆弱性は軽減できるが、静的の方が確実）
    - 静的プレースホルダ
      - 値のバインドをデータベースエンジン側で行う
      - プレースホルダがある状態でSQL文をコンパイルするため、後からSQL文が変更される可能性がない
    - 動的プレースホルダ
      - SQLを呼び出すアプリケーション側のライブラリ内でパラメータをバインドしてからデータベースエンジンに送る方法

```java
// JAVAの例
// This should REALLY be validated too
String custname = request.getParameter("customerName");
// Perform input validation to detect attacks
String query = "SELECT account_balance FROM user_data WHERE user_name = ? ";
PreparedStatement pstmt = connection.prepareStatement( query );
pstmt.setString( 1, custname);
ResultSet results = pstmt.executeQuery( );
```

- **Defense Option 2**：ストアドプロシージャを使用する
  - ストアドプロシージャ
    - DB上での一連処理に, 名前をつけて関数のように, 呼び出して使用できるもの
  - SQLインジェクションに対して常に安全とは限らないが、安全に実装された場合（＝動的にSQL文を生成しない場合）はDefense Option 1のパラメータ化されたクエリと同等の効果がある
  - プリペアドステートメントと違い、SQL文がDB自体に登録され、それをアプリケーション側が呼び出す

```java
// JAVAの例
// This should REALLY be validated
String custname = request.getParameter("customerName");
try {
  CallableStatement cs = connection.prepareCall("{call sp_getAccountBalance(?)}");
  cs.setString(1, custname);
  ResultSet results = cs.executeQuery();
  // … result set handling
} catch (SQLException se) {
  // … logging and error handling
}
```

- **Defense Option 3**：ホワイトリスト式の入力検証
  - SQL文には、テーブル名やカラム名などプレースホルダを使用するには適切ではない箇所も存在する。
  - その場合は、入力を検証するか、SQL文を再設計する必要がある。

- **Defense Option 4**：全てのユーザ入力をエスケープする
  - Defense Option1~3のどれも行えない場合のみ使用（つまりほぼ使うことはない）
  - 他の方法と比べて脆弱で、データベースごとの対応となりがち

- **Additional Defenses**：
  - 権限を必要最小限にする
  - 詳細なエラーメッセージの抑止
    - SQLに関する詳細なエラーメッセージは、SQLインジェクション攻撃を行うための手がかりとなる場合があるため

- 参考
  - [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
  - [安全なウェブサイトの作り方 - 1.1 SQLインジェクション](https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_1.html)

#### CSRF

- トークン埋め込み
  - 多くのフレームワークは、CSRF対策用のトークン発行機能を保持しているため、それを使用する
    - シンクロナイザートークンパターン（同期トークン）
      - セッションまたはリクエストごとに有効期限の短いトークンが生成される
      - クライアントからのリクエストに含まれるトークンとサーバ側が保持するトークンを比較して、有効性を検証する
      - トークンは以下の３つの条件を満たしていること
        - セッションごとに一意
        - 秘密である
        - 予測しづらい
    - 暗号化トークンパターン
      - サーバ側で状態を保持したくない場合に最適なパターン
      - サーバが、サーバのみで使用可能な一意のキーを使用して、セッションIDとタイムスタンプで構成されたトークンを生成する
      - クライアントは、そのトークンをリクエストに含めて送信する
      - リクエストを受け取ったサーバは、そのトークンを復号し、含まれているセッションIDとタイムスタンプを検証する
    - HMACトークンパターン
      - 暗号化トークンパターンと似ているが、暗号化関数ではなく、HMAC関数を使用して暗号化を行う

- Cookieの属性SameSiteを使用する
  - 多くのモダンブラウザでは、`Lax`がデフォルトになりつつある
  - >  画像やフレームをロードするための呼び出しなどのクロスサイトサブリクエストではクッキーが抑止されますが、ユーザーがリンクをクリックするなどして外部サイトからURLに移動すると送信されます

- リクエストヘッダにある`Referer`や`Origin`の値の検証
  - ただし、`Referer`をオフにしているユーザが利用できなくなる可能性がある

- 二重送信クッキー
  - クッキーとリクエストパラメータの両方で、ランダムな値を送信する
  - サーバ側はその２つの値が一致するかどうかを検証する

- カスタムヘッダを設定する
  - サーバ側でそのヘッダと値が存在することを検証する

- 参考
  - [3分でわかるXSSとCSRFの違い](https://qiita.com/wanko5296/items/142b5b82485b0196a2da)

- ユーザ操作による防御
  - 強力な対策ではあるが、UI・UXに影響があるため、これ以外の対策と一緒に使用され、送金やパスワード変更など重要な操作を行う場合に使用することが推奨される
    - 再認証（パスワードの再入力など）
    - ワンタイムトークンの利用
    - CAPTCHA
      - > CAPTCHA とは "Completely Automated Public Turing test to tell Computers and Humans Apart" の略であり、「人間とマシンを判別するチューリングテスト」のことである

- ログインCSRF
  - ログインフォームにトークン（上述のトークン生成方法）を含めることでCSRFの脆弱性を軽減する

- 参考
  - [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
  - [安全なウェブサイトの作り方 - 1.6 CSRF（クロスサイト・リクエスト・フォージェリ）](https://www.ipa.go.jp/security/vuln/websecurity-HTML-1_6.html)

## 参考

- 体系的に学ぶ 安全なWebアプリケーションの作り方（書籍）